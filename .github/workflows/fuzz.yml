name: Fuzzing Pipeline

"on":
  workflow_dispatch:
  # Programa la ejecuciÃ³n diaria a las 02:00Â UTC (20:00 AmÃ©rica/Costa_Rica)
  schedule:
    - cron: '0 2 * * *'

jobs:
  # Fuzzing job: ejecuta AFL++ para cada objetivo definido en la matriz
  fuzz:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - name: png_parser
            build_script: ./targets/png_parser/build.sh
            corpus: ./targets/png_parser/corpus
            run_cmd: "./targets/png_parser/build/pngparse"
          - name: qemu_elf
            build_script: ./targets/qemu_elf/build.sh
            corpus: ./targets/qemu_elf/corpus
            run_cmd: "qemu-arm ./targets/qemu_elf/build/mini_png"
    container:
      image: ghcr.io/sebasteuo/memfuzz-lab:latest
      options: --user 0
    steps:
      - uses: actions/checkout@v4

      # Compila el objetivo definido en la matriz
      - name: Build target
        run: bash ${{ matrix.target.build_script }}

      # Ejecuta AFL++ en modo QEMU (-Q) para compatibilidad con ARM y otras arquitecturas
      # Ajustado a 30â€¯s para pruebas rÃ¡pidas
      - name: Run AFL++ (prueba corta)
        run: |
          AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 \
          timeout 30s afl-fuzz -Q \
            -i ${{ matrix.target.corpus }} \
            -o out_${{ matrix.target.name }} -- \
            ${{ matrix.target.run_cmd }} @@ || true

      # Empaqueta los crashes si existen
      - name: Package crashes
        run: |
          CRASH_DIR="out_${{ matrix.target.name }}/default/crashes"
          if ls "$CRASH_DIR"/id:* 1> /dev/null 2>&1; then
            tar -C "out_${{ matrix.target.name }}/default" -czf crashes-${{ matrix.target.name }}.tar.gz crashes
          fi

      # Sube el artefacto de crashes; ignora si no existe
      - name: Upload crashes
        uses: actions/upload-artifact@v4
        with:
          name: crashes-${{ matrix.target.name }}
          path: crashes-${{ matrix.target.name }}.tar.gz
          if-no-files-found: ignore

  # AnÃ¡lisis de crashes: descarga el artefacto, simboliza y abre Issues
  analyze:
    needs: fuzz
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - name: png_parser
            build_script: ./targets/png_parser/build.sh
            corpus: ./targets/png_parser/corpus
            run_cmd: "./targets/png_parser/build/pngparse"
          - name: qemu_elf
            build_script: ./targets/qemu_elf/build.sh
            corpus: ./targets/qemu_elf/corpus
            run_cmd: "qemu-arm ./targets/qemu_elf/build/mini_png"
    container:
      image: ghcr.io/sebasteuo/memfuzz-lab:latest
      options: --user 0
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: crashes-${{ matrix.target.name }}
          path: .
          if-no-files-found: ignore

      - name: Install gh CLI + llvm-symbolizer
        run: |
          apt-get update -qq
          apt-get install -y --no-install-recommends gh llvm

      # Recompila el objetivo con sÃ­mbolos de depuraciÃ³n
      - name: Rebuild target (symbols)
        run: bash ${{ matrix.target.build_script }}

      # Simboliza cada crash y crea Issues
      - name: Symbolize & create Issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set +e
          trap 'exit 0' EXIT

          # Si no hay archivo de crashes, salir silenciosamente
          [ -f crashes-${{ matrix.target.name }}.tar.gz ] || exit 0
          mkdir -p work
          tar -xzf crashes-${{ matrix.target.name }}.tar.gz -C work

          # Determina la ruta del binario ejecutable
          BIN=$(find ./targets/${{ matrix.target.name }}/build -type f -perm -111 | head -1)

          # Comando para ejecutar el binario (para reproducir el fallo)
          RUN_CMD="${{ matrix.target.run_cmd }}"

          for f in $(find work/crashes -type f -name 'id:*'); do
            # ---------- genera stackâ€‘trace ----------
            ASAN_SYMBOLIZER_PATH=$(which llvm-symbolizer) \
              "$BIN" "$f" 2>&1 > "$(basename "$f").txt" || true
            sleep 2

            summary=$(grep -m1 -v '^$' "$(basename "$f").txt" | cut -c1-120)
            [ -z "$summary" ] && summary="ASAN SEGV crash"
            title="Crash: $summary [$(date +%F-%H%M)]"
            crash_file=$(basename "$f")

            cat > issue_body.md <<EOF_MD
              ### ðŸ’¥ Fuzzing crash detected

              **Target**: \`${{ matrix.target.name }}\`

              **Input**: \`$crash_file\`

              #### Stack trace
              \`\`\`
              $(cat "$(basename "$f").txt")
              \`\`\`

              #### Reproduce locally
              \`\`\`bash
              $RUN_CMD work/crashes/$crash_file
              \`\`\`
              EOF_MD

            gh issue create --title "$title" --body-file issue_body.md || true
          done
